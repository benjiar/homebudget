<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/backend/src/receipts/receipts.controller.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/backend/src/receipts/receipts.controller.ts" />
              <option name="originalContent" value="import { &#10;  Controller, &#10;  Get, &#10;  Post, &#10;  Body, &#10;  Param, &#10;  Delete, &#10;  Query, &#10;  UseGuards, &#10;  Request,&#10;  Patch,&#10;  ParseIntPipe,&#10;  DefaultValuePipe,&#10;  UseInterceptors,&#10;  UploadedFile,&#10;  ParseFilePipe,&#10;  MaxFileSizeValidator,&#10;  FileTypeValidator,&#10;  Headers&#10;} from '@nestjs/common';&#10;import { FileInterceptor } from '@nestjs/platform-express';&#10;import { Express } from 'express';&#10;import { SupabaseAuthGuard } from '../supabase/supabase-auth.guard';&#10;import { ReceiptsService, CreateReceiptDto, UpdateReceiptDto, ReceiptFilters } from './receipts.service';&#10;import { Receipt } from '../entities/receipt.entity';&#10;&#10;@Controller('receipts')&#10;@UseGuards(SupabaseAuthGuard)&#10;export class ReceiptsController {&#10;  constructor(private readonly receiptsService: ReceiptsService) {}&#10;&#10;  @Post()&#10;  async create(@Body() createReceiptDto: CreateReceiptDto, @Request() req: any): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.create(createReceiptDto, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId')&#10;  async findByHousehold(&#10;    @Param('householdId') householdId: string,&#10;    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;    @Query('startDate') startDate?: string,&#10;    @Query('endDate') endDate?: string,&#10;    @Query('categoryIds') categoryIds?: string | string[],&#10;    @Query('minAmount') minAmount?: string,&#10;    @Query('maxAmount') maxAmount?: string,&#10;    @Query('search') search?: string,&#10;  ) {&#10;    const filters: ReceiptFilters = {};&#10;    &#10;    if (startDate) filters.startDate = new Date(startDate);&#10;    if (endDate) filters.endDate = new Date(endDate);&#10;    if (categoryIds) {&#10;      filters.categoryIds = Array.isArray(categoryIds) ? categoryIds : [categoryIds];&#10;    }&#10;    if (minAmount) filters.minAmount = parseFloat(minAmount);&#10;    if (maxAmount) filters.maxAmount = parseFloat(maxAmount);&#10;    if (search) filters.search = search;&#10;&#10;    return this.receiptsService.findByHousehold(householdId, filters, page, limit);&#10;  }&#10;&#10;  @Get()&#10;  async findByHouseholdIds(&#10;    @Headers('x-household-ids') householdIdsHeader: string,&#10;    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;    @Query('startDate') startDate?: string,&#10;    @Query('endDate') endDate?: string,&#10;    @Query('categoryIds') categoryIds?: string | string[],&#10;    @Query('minAmount') minAmount?: string,&#10;    @Query('maxAmount') maxAmount?: string,&#10;    @Query('search') search?: string,&#10;    @Request() req: any&#10;  ) {&#10;    const filters: ReceiptFilters = {};&#10;    if (startDate) filters.startDate = new Date(startDate);&#10;    if (endDate) filters.endDate = new Date(endDate);&#10;    if (categoryIds) {&#10;      filters.categoryIds = Array.isArray(categoryIds) ? categoryIds : [categoryIds];&#10;    }&#10;    if (minAmount) filters.minAmount = parseFloat(minAmount);&#10;    if (maxAmount) filters.maxAmount = parseFloat(maxAmount);&#10;    if (search) filters.search = search;&#10;&#10;    let householdIds: string[];&#10;    try {&#10;      householdIds = JSON.parse(householdIdsHeader);&#10;    } catch {&#10;      householdIds = [];&#10;    }&#10;    return await this.receiptsService.findByHouseholdIds(householdIds, filters, page, limit, req.user.id);&#10;  }&#10;&#10;  @Get(':id')&#10;  async findOne(@Param('id') id: string): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.findOne(id);&#10;  }&#10;&#10;  @Patch(':id')&#10;  async update(&#10;    @Param('id') id: string, &#10;    @Body() updateReceiptDto: UpdateReceiptDto, &#10;    @Request() req: any&#10;  ): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.update(id, updateReceiptDto, req.user.id);&#10;  }&#10;&#10;  @Post(':id/photo')&#10;  @UseInterceptors(FileInterceptor('photo'))&#10;  async uploadPhoto(&#10;    @Param('id') id: string,&#10;    @UploadedFile(&#10;      new ParseFilePipe({&#10;        validators: [&#10;          new MaxFileSizeValidator({ maxSize: 5 * 1024 * 1024 }), // 5MB&#10;          new FileTypeValidator({ fileType: /(jpg|jpeg|png|webp)$/ }),&#10;        ],&#10;      }),&#10;    )&#10;    file: Express.Multer.File,&#10;    @Request() req: any&#10;  ): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.uploadPhoto(id, file, req.user.id);&#10;  }&#10;&#10;  @Delete(':id/photo')&#10;  async deletePhoto(&#10;    @Param('id') id: string,&#10;    @Request() req: any&#10;  ): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.deletePhoto(id, req.user.id);&#10;  }&#10;&#10;  @Delete(':id')&#10;  async remove(@Param('id') id: string, @Request() req: any): Promise&lt;void&gt; {&#10;    return this.receiptsService.remove(id, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId/monthly-report')&#10;  async getMonthlyReport(&#10;    @Param('householdId') householdId: string,&#10;    @Query('month', ParseIntPipe) month: number,&#10;    @Query('year', ParseIntPipe) year: number,&#10;  ) {&#10;    return this.receiptsService.getMonthlyReport(householdId, month, year);&#10;  }&#10;&#10;  @Get('monthly-report')&#10;  async getMonthlyReportForHouseholds(&#10;    @Headers('x-household-ids') householdIdsHeader: string,&#10;    @Query('month', ParseIntPipe) month: number,&#10;    @Query('year', ParseIntPipe) year: number,&#10;    @Request() req: any&#10;  ) {&#10;    let householdIds: string[] = [];&#10;    try {&#10;      householdIds = JSON.parse(householdIdsHeader);&#10;    } catch (e) {&#10;      householdIds = [];&#10;    }&#10;    return this.receiptsService.getMonthlyReportForHouseholds(householdIds, month, year, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId/category/:categoryId')&#10;  async getReceiptsByCategory(&#10;    @Param('householdId') householdId: string,&#10;    @Param('categoryId') categoryId: string,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;  ): Promise&lt;Receipt[]&gt; {&#10;    return this.receiptsService.getReceiptsByCategory(householdId, categoryId, limit);&#10;  }&#10;&#10;  @Get('category/:categoryId/all')&#10;  async getReceiptsByCategoryForHouseholds(&#10;    @Headers('x-household-ids') householdIdsHeader: string,&#10;    @Param('categoryId') categoryId: string,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;    @Request() req: any&#10;  ): Promise&lt;Receipt[]&gt; {&#10;    let householdIds: string[] = [];&#10;    try {&#10;      householdIds = JSON.parse(householdIdsHeader);&#10;    } catch (e) {&#10;      householdIds = [];&#10;    }&#10;    return this.receiptsService.getReceiptsByCategoryMultiple(householdIds, categoryId, limit, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId/expenses-by-date')&#10;  async getExpensesByDateRange(&#10;    @Param('householdId') householdId: string,&#10;    @Query('startDate') startDate: string,&#10;    @Query('endDate') endDate: string,&#10;  ) {&#10;    return this.receiptsService.getExpensesByDateRange(&#10;      householdId, &#10;      new Date(startDate), &#10;      new Date(endDate)&#10;    );&#10;  }&#10;&#10;  @Get('expenses-by-date')&#10;  async getExpensesByDateRangeForHouseholds(&#10;    @Headers('x-household-ids') householdIdsHeader: string,&#10;    @Query('startDate') startDate: string,&#10;    @Query('endDate') endDate: string,&#10;    @Request() req: any&#10;  ) {&#10;    let householdIds: string[] = [];&#10;    try {&#10;      householdIds = JSON.parse(householdIdsHeader);&#10;    } catch (e) {&#10;      householdIds = [];&#10;    }&#10;    return this.receiptsService.getExpensesByDateRangeMultiple(householdIds, new Date(startDate), new Date(endDate), req.user.id);&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { &#10;  Controller, &#10;  Get, &#10;  Post, &#10;  Body, &#10;  Param, &#10;  Delete, &#10;  Query, &#10;  UseGuards, &#10;  Request,&#10;  Patch,&#10;  ParseIntPipe,&#10;  DefaultValuePipe,&#10;  UseInterceptors,&#10;  UploadedFile,&#10;  ParseFilePipe,&#10;  MaxFileSizeValidator,&#10;  FileTypeValidator,&#10;  Headers&#10;} from '@nestjs/common';&#10;import { FileInterceptor } from '@nestjs/platform-express';&#10;import { Express } from 'express';&#10;import { SupabaseAuthGuard } from '../supabase/supabase-auth.guard';&#10;import { ReceiptsService, CreateReceiptDto, UpdateReceiptDto, ReceiptFilters } from './receipts.service';&#10;import { Receipt } from '../entities/receipt.entity';&#10;import { HouseholdHeader } from '../common/decorators/household-header.decorator';&#10;&#10;@Controller('receipts')&#10;@UseGuards(SupabaseAuthGuard)&#10;export class ReceiptsController {&#10;  constructor(private readonly receiptsService: ReceiptsService) {}&#10;&#10;  @Post()&#10;  async create(@Body() createReceiptDto: CreateReceiptDto, @Request() req: any): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.create(createReceiptDto, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId')&#10;  async findByHousehold(&#10;    @Param('householdId') householdId: string,&#10;    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;    @Query('startDate') startDate?: string,&#10;    @Query('endDate') endDate?: string,&#10;    @Query('categoryIds') categoryIds?: string | string[],&#10;    @Query('minAmount') minAmount?: string,&#10;    @Query('maxAmount') maxAmount?: string,&#10;    @Query('search') search?: string,&#10;  ) {&#10;    const filters: ReceiptFilters = {};&#10;    &#10;    if (startDate) filters.startDate = new Date(startDate);&#10;    if (endDate) filters.endDate = new Date(endDate);&#10;    if (categoryIds) {&#10;      filters.categoryIds = Array.isArray(categoryIds) ? categoryIds : [categoryIds];&#10;    }&#10;    if (minAmount) filters.minAmount = parseFloat(minAmount);&#10;    if (maxAmount) filters.maxAmount = parseFloat(maxAmount);&#10;    if (search) filters.search = search;&#10;&#10;    return this.receiptsService.findByHousehold(householdId, filters, page, limit);&#10;  }&#10;&#10;  @Get()&#10;  async findByHouseholdIds(&#10;    @HouseholdHeader() householdIds: string[],&#10;    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;    @Query('startDate') startDate?: string,&#10;    @Query('endDate') endDate?: string,&#10;    @Query('categoryIds') categoryIds?: string | string[],&#10;    @Query('minAmount') minAmount?: string,&#10;    @Query('maxAmount') maxAmount?: string,&#10;    @Query('search') search?: string,&#10;    @Request() req: any&#10;  ) {&#10;    const filters: ReceiptFilters = {};&#10;    if (startDate) filters.startDate = new Date(startDate);&#10;    if (endDate) filters.endDate = new Date(endDate);&#10;    if (categoryIds) {&#10;      filters.categoryIds = Array.isArray(categoryIds) ? categoryIds : [categoryIds];&#10;    }&#10;    if (minAmount) filters.minAmount = parseFloat(minAmount);&#10;    if (maxAmount) filters.maxAmount = parseFloat(maxAmount);&#10;    if (search) filters.search = search;&#10;&#10;    return await this.receiptsService.findByHouseholdIds(householdIds, filters, page, limit, req.user.id);&#10;  }&#10;&#10;  @Get(':id')&#10;  async findOne(@Param('id') id: string): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.findOne(id);&#10;  }&#10;&#10;  @Patch(':id')&#10;  async update(&#10;    @Param('id') id: string, &#10;    @Body() updateReceiptDto: UpdateReceiptDto, &#10;    @Request() req: any&#10;  ): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.update(id, updateReceiptDto, req.user.id);&#10;  }&#10;&#10;  @Post(':id/photo')&#10;  @UseInterceptors(FileInterceptor('photo'))&#10;  async uploadPhoto(&#10;    @Param('id') id: string,&#10;    @UploadedFile(&#10;      new ParseFilePipe({&#10;        validators: [&#10;          new MaxFileSizeValidator({ maxSize: 5 * 1024 * 1024 }), // 5MB&#10;          new FileTypeValidator({ fileType: /(jpg|jpeg|png|webp)$/ }),&#10;        ],&#10;      }),&#10;    )&#10;    file: Express.Multer.File,&#10;    @Request() req: any&#10;  ): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.uploadPhoto(id, file, req.user.id);&#10;  }&#10;&#10;  @Delete(':id/photo')&#10;  async deletePhoto(&#10;    @Param('id') id: string,&#10;    @Request() req: any&#10;  ): Promise&lt;Receipt&gt; {&#10;    return this.receiptsService.deletePhoto(id, req.user.id);&#10;  }&#10;&#10;  @Delete(':id')&#10;  async remove(@Param('id') id: string, @Request() req: any): Promise&lt;void&gt; {&#10;    return this.receiptsService.remove(id, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId/monthly-report')&#10;  async getMonthlyReport(&#10;    @Param('householdId') householdId: string,&#10;    @Query('month', ParseIntPipe) month: number,&#10;    @Query('year', ParseIntPipe) year: number,&#10;  ) {&#10;    return this.receiptsService.getMonthlyReport(householdId, month, year);&#10;  }&#10;&#10;  @Get('monthly-report')&#10;  async getMonthlyReportForHouseholds(&#10;    @HouseholdHeader() householdIds: string[],&#10;    @Query('month', ParseIntPipe) month: number,&#10;    @Query('year', ParseIntPipe) year: number,&#10;    @Request() req: any&#10;  ) {&#10;    return this.receiptsService.getMonthlyReportForHouseholds(householdIds, month, year, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId/category/:categoryId')&#10;  async getReceiptsByCategory(&#10;    @Param('householdId') householdId: string,&#10;    @Param('categoryId') categoryId: string,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;  ): Promise&lt;Receipt[]&gt; {&#10;    return this.receiptsService.getReceiptsByCategory(householdId, categoryId, limit);&#10;  }&#10;&#10;  @Get('category/:categoryId/all')&#10;  async getReceiptsByCategoryForHouseholds(&#10;    @HouseholdHeader() householdIds: string[],&#10;    @Param('categoryId') categoryId: string,&#10;    @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,&#10;    @Request() req: any&#10;  ): Promise&lt;Receipt[]&gt; {&#10;    return this.receiptsService.getReceiptsByCategoryMultiple(householdIds, categoryId, limit, req.user.id);&#10;  }&#10;&#10;  @Get('household/:householdId/expenses-by-date')&#10;  async getExpensesByDateRange(&#10;    @Param('householdId') householdId: string,&#10;    @Query('startDate') startDate: string,&#10;    @Query('endDate') endDate: string,&#10;  ) {&#10;    return this.receiptsService.getExpensesByDateRange(&#10;      householdId, &#10;      new Date(startDate), &#10;      new Date(endDate)&#10;    );&#10;  }&#10;&#10;  @Get('expenses-by-date')&#10;  async getExpensesByDateRangeForHouseholds(&#10;    @HouseholdHeader() householdIds: string[],&#10;    @Query('startDate') startDate: string,&#10;    @Query('endDate') endDate: string,&#10;    @Request() req: any&#10;  ) {&#10;    return this.receiptsService.getExpensesByDateRangeMultiple(householdIds, new Date(startDate), new Date(endDate), req.user.id);&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/backend/src/receipts/receipts.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/backend/src/receipts/receipts.service.ts" />
              <option name="originalContent" value="import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';&#10;import { InjectRepository } from '@nestjs/typeorm';&#10;import { Repository } from 'typeorm';&#10;import { Receipt } from '../entities/receipt.entity';&#10;import { HouseholdMember, HouseholdRole } from '../entities';&#10;import { Category } from '../entities/category.entity';&#10;import { SupabaseService } from '../supabase/supabase.service';&#10;&#10;export interface CreateReceiptDto {&#10;  title: string;&#10;  amount: number;&#10;  receipt_date: Date;&#10;  notes?: string;&#10;  photo_url?: string;&#10;  metadata?: Record&lt;string, any&gt;;&#10;  household_id: string;&#10;  category_id: string;&#10;}&#10;&#10;export interface UpdateReceiptDto {&#10;  title?: string;&#10;  amount?: number;&#10;  receipt_date?: Date;&#10;  notes?: string;&#10;  photo_url?: string;&#10;  metadata?: Record&lt;string, any&gt;;&#10;  category_id?: string;&#10;}&#10;&#10;export interface ReceiptFilters {&#10;  startDate?: Date;&#10;  endDate?: Date;&#10;  categoryIds?: string[];&#10;  minAmount?: number;&#10;  maxAmount?: number;&#10;  search?: string;&#10;}&#10;&#10;export interface ReceiptSummary {&#10;  total_receipts: number;&#10;  total_amount: number;&#10;  average_amount: number;&#10;  by_category: Array&lt;{&#10;    category: Category;&#10;    count: number;&#10;    total: number;&#10;  }&gt;;&#10;}&#10;&#10;@Injectable()&#10;export class ReceiptsService {&#10;  constructor(&#10;    @InjectRepository(Receipt)&#10;    private receiptsRepository: Repository&lt;Receipt&gt;,&#10;    @InjectRepository(HouseholdMember)&#10;    private householdMembersRepository: Repository&lt;HouseholdMember&gt;,&#10;    @InjectRepository(Category)&#10;    private categoriesRepository: Repository&lt;Category&gt;,&#10;    private supabaseService: SupabaseService,&#10;  ) {}&#10;&#10;  async create(createReceiptDto: CreateReceiptDto, userId: string): Promise&lt;Receipt&gt; {&#10;    // Check if user has permission to add receipts to this household&#10;    await this.checkUserPermission(createReceiptDto.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // Verify category belongs to the household&#10;    const category = await this.categoriesRepository.findOne({&#10;      where: { &#10;        id: createReceiptDto.category_id,&#10;        household_id: createReceiptDto.household_id,&#10;      },&#10;    });&#10;&#10;    if (!category) {&#10;      throw new NotFoundException('Category not found or does not belong to this household');&#10;    }&#10;&#10;    const receipt = this.receiptsRepository.create({&#10;      ...createReceiptDto,&#10;      created_by_id: userId,&#10;    });&#10;&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  async findByHousehold(&#10;    householdId: string,&#10;    filters: ReceiptFilters = {},&#10;    page = 1,&#10;    limit = 50&#10;  ): Promise&lt;{ receipts: Receipt[]; total: number; summary: ReceiptSummary }&gt; {&#10;    const queryBuilder = this.receiptsRepository&#10;      .createQueryBuilder('receipt')&#10;      .leftJoinAndSelect('receipt.category', 'category')&#10;      .leftJoinAndSelect('receipt.created_by', 'user')&#10;      .where('receipt.household_id = :householdId', { householdId })&#10;      .orderBy('receipt.receipt_date', 'DESC');&#10;&#10;    // Apply filters&#10;    if (filters.startDate &amp;&amp; filters.endDate) {&#10;      queryBuilder.andWhere('receipt.receipt_date BETWEEN :startDate AND :endDate', {&#10;        startDate: filters.startDate,&#10;        endDate: filters.endDate,&#10;      });&#10;    }&#10;&#10;    if (filters.categoryIds &amp;&amp; filters.categoryIds.length &gt; 0) {&#10;      queryBuilder.andWhere('receipt.category_id IN (:...categoryIds)', {&#10;        categoryIds: filters.categoryIds,&#10;      });&#10;    }&#10;&#10;    if (filters.minAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &gt;= :minAmount', { minAmount: filters.minAmount });&#10;    }&#10;&#10;    if (filters.maxAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &lt;= :maxAmount', { maxAmount: filters.maxAmount });&#10;    }&#10;&#10;    if (filters.search) {&#10;      queryBuilder.andWhere(&#10;        '(receipt.title ILIKE :search OR receipt.notes ILIKE :search)',&#10;        { search: `%${filters.search}%` }&#10;      );&#10;    }&#10;&#10;    // Get total count for pagination&#10;    const total = await queryBuilder.getCount();&#10;&#10;    // Apply pagination&#10;    const receipts = await queryBuilder&#10;      .skip((page - 1) * limit)&#10;      .take(limit)&#10;      .getMany();&#10;&#10;    // Generate summary&#10;    const summary = await this.generateSummary(householdId, filters);&#10;&#10;    return { receipts, total, summary };&#10;  }&#10;&#10;  async findOne(id: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.receiptsRepository.findOne({&#10;      where: { id },&#10;      relations: ['household', 'category', 'created_by'],&#10;    });&#10;&#10;    if (!receipt) {&#10;      throw new NotFoundException(`Receipt with ID ${id} not found`);&#10;    }&#10;&#10;    return receipt;&#10;  }&#10;&#10;  async update(id: string, updateReceiptDto: UpdateReceiptDto, userId: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to update receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // If updating category, verify it belongs to the household&#10;    if (updateReceiptDto.category_id) {&#10;      const category = await this.categoriesRepository.findOne({&#10;        where: { &#10;          id: updateReceiptDto.category_id,&#10;          household_id: receipt.household_id,&#10;        },&#10;      });&#10;&#10;      if (!category) {&#10;        throw new NotFoundException('Category not found or does not belong to this household');&#10;      }&#10;    }&#10;&#10;    Object.assign(receipt, updateReceiptDto);&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  async remove(id: string, userId: string): Promise&lt;void&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to delete receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // Delete photo if it exists&#10;    if (receipt.photo_url) {&#10;      await this.deleteReceiptPhoto(receipt);&#10;    }&#10;&#10;    await this.receiptsRepository.remove(receipt);&#10;  }&#10;&#10;  async getMonthlyReport(householdId: string, month: number, year: number): Promise&lt;ReceiptSummary&gt; {&#10;    const startDate = new Date(year, month - 1, 1);&#10;    const endDate = new Date(year, month, 0);&#10;&#10;    return await this.generateSummary(householdId, { startDate, endDate });&#10;  }&#10;&#10;  async getReceiptsByCategory(&#10;    householdId: string,&#10;    categoryId: string,&#10;    limit = 20&#10;  ): Promise&lt;Receipt[]&gt; {&#10;    return await this.receiptsRepository.find({&#10;      where: { &#10;        household_id: householdId,&#10;        category_id: categoryId,&#10;      },&#10;      relations: ['category', 'created_by'],&#10;      order: { receipt_date: 'DESC' },&#10;      take: limit,&#10;    });&#10;  }&#10;&#10;  async getExpensesByDateRange(&#10;    householdId: string,&#10;    startDate: Date,&#10;    endDate: Date&#10;  ): Promise&lt;Array&lt;{ date: string; total: number; count: number }&gt;&gt; {&#10;    const result = await this.receiptsRepository&#10;      .createQueryBuilder('receipt')&#10;      .select('DATE(receipt.receipt_date) as date')&#10;      .addSelect('SUM(receipt.amount)', 'total')&#10;      .addSelect('COUNT(*)', 'count')&#10;      .where('receipt.household_id = :householdId', { householdId })&#10;      .andWhere('receipt.receipt_date BETWEEN :startDate AND :endDate', { startDate, endDate })&#10;      .groupBy('DATE(receipt.receipt_date)')&#10;      .orderBy('date', 'ASC')&#10;      .getRawMany();&#10;&#10;    return result.map(row =&gt; ({&#10;      date: row.date,&#10;      total: parseFloat(row.total),&#10;      count: parseInt(row.count),&#10;    }));&#10;  }&#10;&#10;  async uploadPhoto(id: string, file: Express.Multer.File, userId: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to update receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // Delete existing photo if it exists&#10;    if (receipt.photo_url) {&#10;      await this.deleteReceiptPhoto(receipt);&#10;    }&#10;&#10;    // Create bucket if it doesn't exist&#10;    await this.supabaseService.createBucket('receipt-photos');&#10;&#10;    // Generate unique file path&#10;    const fileExtension = file.originalname.split('.').pop() || 'jpg';&#10;    const fileName = `${receipt.household_id}/${receipt.id}/${Date.now()}.${fileExtension}`;&#10;&#10;    // Upload file to Supabase Storage&#10;    const { publicUrl } = await this.supabaseService.uploadFile(&#10;      'receipt-photos',&#10;      fileName,&#10;      file.buffer,&#10;      file.mimetype&#10;    );&#10;&#10;    // Update receipt with photo URL&#10;    receipt.photo_url = publicUrl;&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  async deletePhoto(id: string, userId: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to update receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    if (!receipt.photo_url) {&#10;      throw new NotFoundException('Receipt does not have a photo');&#10;    }&#10;&#10;    // Delete photo from storage&#10;    await this.deleteReceiptPhoto(receipt);&#10;&#10;    // Update receipt to remove photo URL&#10;    receipt.photo_url = null;&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  private async deleteReceiptPhoto(receipt: Receipt): Promise&lt;void&gt; {&#10;    if (!receipt.photo_url) return;&#10;&#10;    try {&#10;      // Extract file path from public URL&#10;      // Supabase public URLs format: https://project.supabase.co/storage/v1/object/public/bucket/path&#10;      const urlParts = receipt.photo_url.split('/');&#10;      const bucketIndex = urlParts.findIndex(part =&gt; part === 'receipt-photos');&#10;      &#10;      if (bucketIndex !== -1 &amp;&amp; bucketIndex &lt; urlParts.length - 1) {&#10;        const filePath = urlParts.slice(bucketIndex + 1).join('/');&#10;        await this.supabaseService.deleteFile('receipt-photos', filePath);&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to delete photo from storage:', error);&#10;      // Don't throw error here as we still want to update the database&#10;    }&#10;  }&#10;&#10;  private async generateSummary(householdId: string, filters: ReceiptFilters = {}): Promise&lt;ReceiptSummary&gt; {&#10;    const queryBuilder = this.receiptsRepository&#10;      .createQueryBuilder('receipt')&#10;      .leftJoin('receipt.category', 'category')&#10;      .where('receipt.household_id = :householdId', { householdId });&#10;&#10;    // Apply same filters as in findByHousehold&#10;    if (filters.startDate &amp;&amp; filters.endDate) {&#10;      queryBuilder.andWhere('receipt.receipt_date BETWEEN :startDate AND :endDate', {&#10;        startDate: filters.startDate,&#10;        endDate: filters.endDate,&#10;      });&#10;    }&#10;&#10;    if (filters.categoryIds &amp;&amp; filters.categoryIds.length &gt; 0) {&#10;      queryBuilder.andWhere('receipt.category_id IN (:...categoryIds)', {&#10;        categoryIds: filters.categoryIds,&#10;      });&#10;    }&#10;&#10;    if (filters.minAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &gt;= :minAmount', { minAmount: filters.minAmount });&#10;    }&#10;&#10;    if (filters.maxAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &lt;= :maxAmount', { maxAmount: filters.maxAmount });&#10;    }&#10;&#10;    if (filters.search) {&#10;      queryBuilder.andWhere(&#10;        '(receipt.title ILIKE :search OR receipt.notes ILIKE :search)',&#10;        { search: `%${filters.search}%` }&#10;      );&#10;    }&#10;&#10;    // Get totals&#10;    const totalsResult = await queryBuilder&#10;      .select('COUNT(*)', 'total_receipts')&#10;      .addSelect('SUM(receipt.amount)', 'total_amount')&#10;      .addSelect('AVG(receipt.amount)', 'average_amount')&#10;      .getRawOne();&#10;&#10;    // Get category breakdown&#10;    const categoryBreakdown = await queryBuilder&#10;      .select('category.id', 'category_id')&#10;      .addSelect('category.name', 'category_name')&#10;      .addSelect('COUNT(*)', 'count')&#10;      .addSelect('SUM(receipt.amount)', 'total')&#10;      .groupBy('category.id, category.name')&#10;      .orderBy('total', 'DESC')&#10;      .getRawMany();&#10;&#10;    // Convert category breakdown to include full category objects&#10;    const by_category = await Promise.all(&#10;      categoryBreakdown.map(async (item) =&gt; {&#10;        const category = await this.categoriesRepository.findOne({&#10;          where: { id: item.category_id },&#10;        });&#10;        return {&#10;          category: category!,&#10;          count: parseInt(item.count),&#10;          total: parseFloat(item.total),&#10;        };&#10;      })&#10;    );&#10;&#10;    return {&#10;      total_receipts: parseInt(totalsResult.total_receipts) || 0,&#10;      total_amount: parseFloat(totalsResult.total_amount) || 0,&#10;      average_amount: parseFloat(totalsResult.average_amount) || 0,&#10;      by_category,&#10;    };&#10;  }&#10;&#10;  private async checkUserPermission(&#10;    householdId: string,&#10;    userId: string,&#10;    allowedRoles: HouseholdRole[]&#10;  ): Promise&lt;void&gt; {&#10;    const membership = await this.householdMembersRepository.findOne({&#10;      where: {&#10;        user_id: userId,&#10;        household_id: householdId,&#10;        is_active: true,&#10;      },&#10;    });&#10;&#10;    if (!membership || !allowedRoles.includes(membership.role)) {&#10;      throw new ForbiddenException('Insufficient permissions for this operation');&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';&#10;import { InjectRepository } from '@nestjs/typeorm';&#10;import { Repository, In } from 'typeorm';&#10;import { Receipt } from '../entities/receipt.entity';&#10;import { HouseholdMember, HouseholdRole } from '../entities';&#10;import { Category } from '../entities/category.entity';&#10;import { SupabaseService } from '../supabase/supabase.service';&#10;&#10;export interface CreateReceiptDto {&#10;  title: string;&#10;  amount: number;&#10;  receipt_date: Date;&#10;  notes?: string;&#10;  photo_url?: string;&#10;  metadata?: Record&lt;string, any&gt;;&#10;  household_id: string;&#10;  category_id: string;&#10;}&#10;&#10;export interface UpdateReceiptDto {&#10;  title?: string;&#10;  amount?: number;&#10;  receipt_date?: Date;&#10;  notes?: string;&#10;  photo_url?: string;&#10;  metadata?: Record&lt;string, any&gt;;&#10;  category_id?: string;&#10;}&#10;&#10;export interface ReceiptFilters {&#10;  startDate?: Date;&#10;  endDate?: Date;&#10;  categoryIds?: string[];&#10;  minAmount?: number;&#10;  maxAmount?: number;&#10;  search?: string;&#10;}&#10;&#10;export interface ReceiptSummary {&#10;  total_receipts: number;&#10;  total_amount: number;&#10;  average_amount: number;&#10;  by_category: Array&lt;{&#10;    category: Category;&#10;    count: number;&#10;    total: number;&#10;  }&gt;;&#10;}&#10;&#10;@Injectable()&#10;export class ReceiptsService {&#10;  constructor(&#10;    @InjectRepository(Receipt)&#10;    private receiptsRepository: Repository&lt;Receipt&gt;,&#10;    @InjectRepository(HouseholdMember)&#10;    private householdMembersRepository: Repository&lt;HouseholdMember&gt;,&#10;    @InjectRepository(Category)&#10;    private categoriesRepository: Repository&lt;Category&gt;,&#10;    private supabaseService: SupabaseService,&#10;  ) {}&#10;&#10;  async create(createReceiptDto: CreateReceiptDto, userId: string): Promise&lt;Receipt&gt; {&#10;    // Check if user has permission to add receipts to this household&#10;    await this.checkUserPermission(createReceiptDto.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // Verify category belongs to the household&#10;    const category = await this.categoriesRepository.findOne({&#10;      where: { &#10;        id: createReceiptDto.category_id,&#10;        household_id: createReceiptDto.household_id,&#10;      },&#10;    });&#10;&#10;    if (!category) {&#10;      throw new NotFoundException('Category not found or does not belong to this household');&#10;    }&#10;&#10;    const receipt = this.receiptsRepository.create({&#10;      ...createReceiptDto,&#10;      created_by_id: userId,&#10;    });&#10;&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  async findByHousehold(&#10;    householdId: string,&#10;    filters: ReceiptFilters = {},&#10;    page = 1,&#10;    limit = 50&#10;  ): Promise&lt;{ receipts: Receipt[]; total: number; summary: ReceiptSummary }&gt; {&#10;    const queryBuilder = this.receiptsRepository&#10;      .createQueryBuilder('receipt')&#10;      .leftJoinAndSelect('receipt.category', 'category')&#10;      .leftJoinAndSelect('receipt.created_by', 'user')&#10;      .where('receipt.household_id = :householdId', { householdId })&#10;      .orderBy('receipt.receipt_date', 'DESC');&#10;&#10;    // Apply filters&#10;    if (filters.startDate &amp;&amp; filters.endDate) {&#10;      queryBuilder.andWhere('receipt.receipt_date BETWEEN :startDate AND :endDate', {&#10;        startDate: filters.startDate,&#10;        endDate: filters.endDate,&#10;      });&#10;    }&#10;&#10;    if (filters.categoryIds &amp;&amp; filters.categoryIds.length &gt; 0) {&#10;      queryBuilder.andWhere('receipt.category_id IN (:...categoryIds)', {&#10;        categoryIds: filters.categoryIds,&#10;      });&#10;    }&#10;&#10;    if (filters.minAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &gt;= :minAmount', { minAmount: filters.minAmount });&#10;    }&#10;&#10;    if (filters.maxAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &lt;= :maxAmount', { maxAmount: filters.maxAmount });&#10;    }&#10;&#10;    if (filters.search) {&#10;      queryBuilder.andWhere(&#10;        '(receipt.title ILIKE :search OR receipt.notes ILIKE :search)',&#10;        { search: `%${filters.search}%` }&#10;      );&#10;    }&#10;&#10;    // Get total count for pagination&#10;    const total = await queryBuilder.getCount();&#10;&#10;    // Apply pagination&#10;    const receipts = await queryBuilder&#10;      .skip((page - 1) * limit)&#10;      .take(limit)&#10;      .getMany();&#10;&#10;    // Generate summary&#10;    const summary = await this.generateSummary(householdId, filters);&#10;&#10;    return { receipts, total, summary };&#10;  }&#10;&#10;  async findByHouseholdIds(&#10;    householdIds: string[],&#10;    filters: ReceiptFilters = {},&#10;    page = 1,&#10;    limit = 50,&#10;    userId: string&#10;  ): Promise&lt;{ receipts: Receipt[]; total: number; summary: ReceiptSummary }&gt; {&#10;    if (!householdIds || householdIds.length === 0) {&#10;      // Optionally, get all households for the user&#10;      const userHouseholds = await this.householdMembersRepository.find({ where: { user_id: userId } });&#10;      householdIds = userHouseholds.map(hm =&gt; hm.household_id);&#10;    }&#10;    const queryBuilder = this.receiptsRepository&#10;      .createQueryBuilder('receipt')&#10;      .leftJoinAndSelect('receipt.category', 'category')&#10;      .leftJoinAndSelect('receipt.created_by', 'user')&#10;      .where('receipt.household_id IN (:...householdIds)', { householdIds })&#10;      .orderBy('receipt.receipt_date', 'DESC');&#10;&#10;    // Apply filters&#10;    if (filters.startDate &amp;&amp; filters.endDate) {&#10;      queryBuilder.andWhere('receipt.receipt_date BETWEEN :startDate AND :endDate', {&#10;        startDate: filters.startDate,&#10;        endDate: filters.endDate,&#10;      });&#10;    }&#10;    if (filters.categoryIds &amp;&amp; filters.categoryIds.length &gt; 0) {&#10;      queryBuilder.andWhere('receipt.category_id IN (:...categoryIds)', {&#10;        categoryIds: filters.categoryIds,&#10;      });&#10;    }&#10;    if (filters.minAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &gt;= :minAmount', { minAmount: filters.minAmount });&#10;    }&#10;    if (filters.maxAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &lt;= :maxAmount', { maxAmount: filters.maxAmount });&#10;    }&#10;    if (filters.search) {&#10;      queryBuilder.andWhere(&#10;        '(receipt.title ILIKE :search OR receipt.notes ILIKE :search)',&#10;        { search: `%${filters.search}%` }&#10;      );&#10;    }&#10;    // Get total count for pagination&#10;    const total = await queryBuilder.getCount();&#10;    // Apply pagination&#10;    const receipts = await queryBuilder&#10;      .skip((page - 1) * limit)&#10;      .take(limit)&#10;      .getMany();&#10;    // Generate summary (for first household only)&#10;    const summary = householdIds.length &gt; 0 ? await this.generateSummary(householdIds[0], filters) : null;&#10;    return { receipts, total, summary };&#10;  }&#10;&#10;  async findOne(id: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.receiptsRepository.findOne({&#10;      where: { id },&#10;      relations: ['household', 'category', 'created_by'],&#10;    });&#10;&#10;    if (!receipt) {&#10;      throw new NotFoundException(`Receipt with ID ${id} not found`);&#10;    }&#10;&#10;    return receipt;&#10;  }&#10;&#10;  async update(id: string, updateReceiptDto: UpdateReceiptDto, userId: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to update receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // If updating category, verify it belongs to the household&#10;    if (updateReceiptDto.category_id) {&#10;      const category = await this.categoriesRepository.findOne({&#10;        where: { &#10;          id: updateReceiptDto.category_id,&#10;          household_id: receipt.household_id,&#10;        },&#10;      });&#10;&#10;      if (!category) {&#10;        throw new NotFoundException('Category not found or does not belong to this household');&#10;      }&#10;    }&#10;&#10;    Object.assign(receipt, updateReceiptDto);&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  async remove(id: string, userId: string): Promise&lt;void&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to delete receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // Delete photo if it exists&#10;    if (receipt.photo_url) {&#10;      await this.deleteReceiptPhoto(receipt);&#10;    }&#10;&#10;    await this.receiptsRepository.remove(receipt);&#10;  }&#10;&#10;  async getMonthlyReport(householdId: string, month: number, year: number): Promise&lt;ReceiptSummary&gt; {&#10;    const startDate = new Date(year, month - 1, 1);&#10;    const endDate = new Date(year, month, 0);&#10;&#10;    return await this.generateSummary(householdId, { startDate, endDate });&#10;  }&#10;&#10;  // New: resolve allowed household ids for a user (if none provided, returns all user's households)&#10;  private async resolveAllowedHouseholdIds(householdIds: string[] | undefined, userId: string): Promise&lt;string[]&gt; {&#10;    if (!householdIds || householdIds.length === 0) {&#10;      const userHouseholds = await this.householdMembersRepository.find({ where: { user_id: userId, is_active: true } });&#10;      return userHouseholds.map(hm =&gt; hm.household_id);&#10;    }&#10;&#10;    // Validate the user is a member of the provided households&#10;    const memberships = await this.householdMembersRepository.find({ where: { user_id: userId, is_active: true, household_id: In(householdIds) } });&#10;    return memberships.map(m =&gt; m.household_id);&#10;  }&#10;&#10;  async getMonthlyReportForHouseholds(householdIds: string[], month: number, year: number, userId: string): Promise&lt;ReceiptSummary&gt; {&#10;    const allowedIds = await this.resolveAllowedHouseholdIds(householdIds, userId);&#10;&#10;    // If user has no allowed households, return empty summary&#10;    if (!allowedIds || allowedIds.length === 0) {&#10;      return { total_receipts: 0, total_amount: 0, average_amount: 0, by_category: [] };&#10;    }&#10;&#10;    // Aggregate summaries across allowed households&#10;    let totalReceipts = 0;&#10;    let totalAmount = 0;&#10;    const categoryMap: Map&lt;string, { category: Category; count: number; total: number }&gt; = new Map();&#10;&#10;    for (const hid of allowedIds) {&#10;      const summary = await this.generateSummary(hid, { startDate: new Date(year, month - 1, 1), endDate: new Date(year, month, 0) });&#10;      totalReceipts += summary.total_receipts;&#10;      totalAmount += summary.total_amount;&#10;      for (const item of summary.by_category) {&#10;        const key = item.category.id;&#10;        const existing = categoryMap.get(key);&#10;        if (existing) {&#10;          existing.count += item.count;&#10;          existing.total += item.total;&#10;        } else {&#10;          categoryMap.set(key, { category: item.category, count: item.count, total: item.total });&#10;        }&#10;      }&#10;    }&#10;&#10;    const by_category = Array.from(categoryMap.values()).sort((a, b) =&gt; b.total - a.total);&#10;    const averageAmount = totalReceipts &gt; 0 ? totalAmount / totalReceipts : 0;&#10;&#10;    return {&#10;      total_receipts: totalReceipts,&#10;      total_amount: totalAmount,&#10;      average_amount: averageAmount,&#10;      by_category,&#10;    };&#10;  }&#10;&#10;  async getReceiptsByCategoryMultiple(householdIds: string[], categoryId: string, limit = 20, userId: string): Promise&lt;Receipt[]&gt; {&#10;    const allowedIds = await this.resolveAllowedHouseholdIds(householdIds, userId);&#10;    if (!allowedIds || allowedIds.length === 0) return [];&#10;&#10;    return await this.receiptsRepository.find({&#10;      where: {&#10;        household_id: In(allowedIds),&#10;        category_id: categoryId,&#10;      },&#10;      relations: ['category', 'created_by'],&#10;      order: { receipt_date: 'DESC' },&#10;      take: limit,&#10;    });&#10;  }&#10;&#10;  async getExpensesByDateRangeMultiple(householdIds: string[], startDate: Date, endDate: Date, userId: string): Promise&lt;Array&lt;{ date: string; total: number; count: number }&gt;&gt; {&#10;    const allowedIds = await this.resolveAllowedHouseholdIds(householdIds, userId);&#10;    if (!allowedIds || allowedIds.length === 0) return [];&#10;&#10;    const result = await this.receiptsRepository&#10;      .createQueryBuilder('receipt')&#10;      .select('DATE(receipt.receipt_date) as date')&#10;      .addSelect('SUM(receipt.amount)', 'total')&#10;      .addSelect('COUNT(*)', 'count')&#10;      .where('receipt.household_id IN (:...allowedIds)', { allowedIds })&#10;      .andWhere('receipt.receipt_date BETWEEN :startDate AND :endDate', { startDate, endDate })&#10;      .groupBy('DATE(receipt.receipt_date)')&#10;      .orderBy('date', 'ASC')&#10;      .getRawMany();&#10;&#10;    return result.map(row =&gt; ({&#10;      date: row.date,&#10;      total: parseFloat(row.total),&#10;      count: parseInt(row.count),&#10;    }));&#10;  }&#10;&#10;  async uploadPhoto(id: string, file: Express.Multer.File, userId: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to update receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    // Delete existing photo if it exists&#10;    if (receipt.photo_url) {&#10;      await this.deleteReceiptPhoto(receipt);&#10;    }&#10;&#10;    // Create bucket if it doesn't exist&#10;    await this.supabaseService.createBucket('receipt-photos');&#10;&#10;    // Generate unique file path&#10;    const fileExtension = file.originalname.split('.').pop() || 'jpg';&#10;    const fileName = `${receipt.household_id}/${receipt.id}/${Date.now()}.${fileExtension}`;&#10;&#10;    // Upload file to Supabase Storage&#10;    const { publicUrl } = await this.supabaseService.uploadFile(&#10;      'receipt-photos',&#10;      fileName,&#10;      file.buffer,&#10;      file.mimetype&#10;    );&#10;&#10;    // Update receipt with photo URL&#10;    receipt.photo_url = publicUrl;&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  async deletePhoto(id: string, userId: string): Promise&lt;Receipt&gt; {&#10;    const receipt = await this.findOne(id);&#10;&#10;    // Check if user has permission to update receipts in this household&#10;    await this.checkUserPermission(receipt.household_id, userId, [&#10;      HouseholdRole.OWNER,&#10;      HouseholdRole.ADMIN,&#10;      HouseholdRole.MEMBER,&#10;    ]);&#10;&#10;    if (!receipt.photo_url) {&#10;      throw new NotFoundException('Receipt does not have a photo');&#10;    }&#10;&#10;    // Delete photo from storage&#10;    await this.deleteReceiptPhoto(receipt);&#10;&#10;    // Update receipt to remove photo URL&#10;    receipt.photo_url = null;&#10;    return await this.receiptsRepository.save(receipt);&#10;  }&#10;&#10;  private async deleteReceiptPhoto(receipt: Receipt): Promise&lt;void&gt; {&#10;    if (!receipt.photo_url) return;&#10;&#10;    try {&#10;      // Extract file path from public URL&#10;      // Supabase public URLs format: https://project.supabase.co/storage/v1/object/public/bucket/path&#10;      const urlParts = receipt.photo_url.split('/');&#10;      const bucketIndex = urlParts.findIndex(part =&gt; part === 'receipt-photos');&#10;      &#10;      if (bucketIndex !== -1 &amp;&amp; bucketIndex &lt; urlParts.length - 1) {&#10;        const filePath = urlParts.slice(bucketIndex + 1).join('/');&#10;        await this.supabaseService.deleteFile('receipt-photos', filePath);&#10;      }&#10;    } catch (error) {&#10;      console.error('Failed to delete photo from storage:', error);&#10;      // Don't throw error here as we still want to update the database&#10;    }&#10;  }&#10;&#10;  private async generateSummary(householdId: string, filters: ReceiptFilters = {}): Promise&lt;ReceiptSummary&gt; {&#10;    const queryBuilder = this.receiptsRepository&#10;      .createQueryBuilder('receipt')&#10;      .leftJoin('receipt.category', 'category')&#10;      .where('receipt.household_id = :householdId', { householdId });&#10;&#10;    // Apply same filters as in findByHousehold&#10;    if (filters.startDate &amp;&amp; filters.endDate) {&#10;      queryBuilder.andWhere('receipt.receipt_date BETWEEN :startDate AND :endDate', {&#10;        startDate: filters.startDate,&#10;        endDate: filters.endDate,&#10;      });&#10;    }&#10;&#10;    if (filters.categoryIds &amp;&amp; filters.categoryIds.length &gt; 0) {&#10;      queryBuilder.andWhere('receipt.category_id IN (:...categoryIds)', {&#10;        categoryIds: filters.categoryIds,&#10;      });&#10;    }&#10;&#10;    if (filters.minAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &gt;= :minAmount', { minAmount: filters.minAmount });&#10;    }&#10;&#10;    if (filters.maxAmount !== undefined) {&#10;      queryBuilder.andWhere('receipt.amount &lt;= :maxAmount', { maxAmount: filters.maxAmount });&#10;    }&#10;&#10;    if (filters.search) {&#10;      queryBuilder.andWhere(&#10;        '(receipt.title ILIKE :search OR receipt.notes ILIKE :search)',&#10;        { search: `%${filters.search}%` }&#10;      );&#10;    }&#10;&#10;    // Get totals&#10;    const totalsResult = await queryBuilder&#10;      .select('COUNT(*)', 'total_receipts')&#10;      .addSelect('SUM(receipt.amount)', 'total_amount')&#10;      .addSelect('AVG(receipt.amount)', 'average_amount')&#10;      .getRawOne();&#10;&#10;    // Get category breakdown&#10;    const categoryBreakdown = await queryBuilder&#10;      .select('category.id', 'category_id')&#10;      .addSelect('category.name', 'category_name')&#10;      .addSelect('COUNT(*)', 'count')&#10;      .addSelect('SUM(receipt.amount)', 'total')&#10;      .groupBy('category.id, category.name')&#10;      .orderBy('total', 'DESC')&#10;      .getRawMany();&#10;&#10;    // Convert category breakdown to include full category objects&#10;    const by_category = await Promise.all(&#10;      categoryBreakdown.map(async (item) =&gt; {&#10;        const category = await this.categoriesRepository.findOne({&#10;          where: { id: item.category_id },&#10;        });&#10;        return {&#10;          category: category!,&#10;          count: parseInt(item.count),&#10;          total: parseFloat(item.total),&#10;        };&#10;      })&#10;    );&#10;&#10;    return {&#10;      total_receipts: parseInt(totalsResult.total_receipts) || 0,&#10;      total_amount: parseFloat(totalsResult.total_amount) || 0,&#10;      average_amount: parseFloat(totalsResult.average_amount) || 0,&#10;      by_category,&#10;    };&#10;  }&#10;&#10;  private async checkUserPermission(&#10;    householdId: string,&#10;    userId: string,&#10;    allowedRoles: HouseholdRole[]&#10;  ): Promise&lt;void&gt; {&#10;    const membership = await this.householdMembersRepository.findOne({&#10;      where: {&#10;        user_id: userId,&#10;        household_id: householdId,&#10;        is_active: true,&#10;      },&#10;    });&#10;&#10;    if (!membership || !allowedRoles.includes(membership.role)) {&#10;      throw new ForbiddenException('Insufficient permissions for this operation');&#10;    }&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>